[{"title":"如何授权指定服务器","date":"2017-04-07T05:02:00.878Z","path":"2017/04/07/授权某台服务器的copyright/","text":"在软件开发过程中，为了保护开发版权，需要仅仅授权给某台服务器使用。这里通过限定机器mac和ip地址来做版权验证。原理：releaseLicense方法查询服务器的mac地址和ip地址，通过md5加密，生成一串密钥key。然后将授权信息进行RC4加密，进行16进制转换，得到一串数据，保存成dat文件。 function releaseLicense(callback) { exec(&quot;ifconfig &quot; + masConf.cmd, function(error, stdout, stderr) { if (!stderr) { var ip = mac = &#39;&#39;; var data = stdout.match(/inet addr:(.*) Bcast/); if (data) ip = data[1].trim(); data = stdout.match(/HWaddr(.*) /); if (data) mac = data[1].trim(); ip = ipConversion(ip); mac = mac.toUpperCase(); console.log(&quot;ip: &quot;, ip); console.log(&quot;mac: &quot;, mac); var md5 = crypto.createHash(&#39;md5&#39;); md5.update(ip); md5.update(mac); md5.update(service); md5.update(privateKey); var encryptKey = md5.digest(&#39;hex&#39;).toUpperCase(); callback(encryptKey); } else { callback(false); } }); } RC4加密解密： function rc4codec(key, text) { var s = new Array(); for (var i = 0; i &lt; 256; i++) { s[i] = i; } var j = 0, x; for (i = 0; i &lt; 256; i++) { j = (j + s[i] + key.charCodeAt(i % key.length)) % 256; x = s[i]; s[i] = s[j]; s[j] = x; } i = j = 0; var ct = []; for (var y = 0; y &lt; text.length; y++) { i = (i + 1) % 256; j = (j + s[i]) % 256; x = s[i]; s[i] = s[j]; s[j] = x; ct.push(text[y] ^ s[(s[i] + s[j]) % 256]); } return new Buffer(ct); } 验证授权方法： //获取加密后的16进制文件 var Ciphertext = fs.readFileSync(&#39;STMLicense.dat&#39;); //通过RC4解密 var betaCipherdata = rc4codec(betaEncryptKey, new Buffer(Ciphertext, &quot;hex&quot;)).toString(); 解密后验证授权信息是否正确即可。","tags":[{"name":"nodejs授权","slug":"nodejs授权","permalink":"http://139.129.18.59/tags/nodejs授权/"},{"name":"rc4加密","slug":"rc4加密","permalink":"http://139.129.18.59/tags/rc4加密/"}]},{"title":"静夜思","date":"2017-03-10T14:10:06.000Z","path":"2017/03/10/jingyesi/","text":"喜欢一个人静静的听歌","tags":[{"name":"随笔","slug":"随笔","permalink":"http://139.129.18.59/tags/随笔/"}]},{"title":"理解RESTful架构","date":"2016-12-15T04:10:06.000Z","path":"2016/12/15/restFul/","text":"越来越多的人开始意识到，网站即软件，而且是一种新型的软件。这种”互联网软件”采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，现在我们必须考虑，如何开发在互联网环境中使用的软件。RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。但是，到底什么是RESTful架构，并不是一个容易说清楚的问题。下面，我就谈谈我理解的RESTful架构。 一、起源REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。他这样介绍论文的写作目的： “本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。”(This dissertation explores a junction on the frontiers of two research disciplines in computer science: software and networking. Software research has long been concerned with the categorization of software designs and the development of design methodologies, but has rarely been able to objectively evaluate the impact of various design choices on system behavior. Networking research, in contrast, is focused on the details of generic communication behavior between systems and improving the performance of particular communication techniques, often ignoring the fact that changing the interaction style of an application can have more impact on performance than the communication protocols used for that interaction. My work is motivated by the desire to understand and evaluate the architectural design of network-based application software through principled use of architectural constraints, thereby obtaining the functional, performance, and social properties desired of an architecture. ) 二、名称Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是&quot;表现层状态转化&quot;。如果一个架构符合REST原则，就称它为RESTful架构。要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。 三、资源（Resources）REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。 四、表现层（Representation）“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。 五、状态转化（State Transfer）访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 六、综述综合上面的解释，我们总结一下什么是RESTful架构： 每一个URI代表一种资源； 客户端和服务器之间，传递这种资源的某种表现层； 客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 七、误区RESTful架构有一些典型的设计误区。最常见的一种设计错误，就是URI包含动词。因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。举例来说，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：POST /accounts/1/transfer/500/to/2正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务: POST /transaction HTTP/1.1 Host: 127.0.0.1 from=1&amp;to=2&amp;amount=500.00 另一个设计误区，就是在URI中加入版本号： http://www.example.com/app/1.0/foo http://www.example.com/app/1.1/foo http://www.example.com/app/2.0/foo 因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见Versioning REST Services): Accept: vnd.example-com.foo+json; version=1.0 Accept: vnd.example-com.foo+json; version=1.1 Accept: vnd.example-com.foo+json; version=2.0 （完）","tags":[{"name":"网络","slug":"网络","permalink":"http://139.129.18.59/tags/网络/"},{"name":"RESTful","slug":"RESTful","permalink":"http://139.129.18.59/tags/RESTful/"}]},{"title":"Atom工具的使用","date":"2016-11-25T04:10:06.000Z","path":"2016/11/25/atom的使用/","text":"Atom是git内部使用的编辑器，现在开源了，官网地址:https://atom.io/这里推荐某大大的博客介绍：http://blog.csdn.net/crper/article/details/45786335 第一次打开时会发现文件显示多了.DS_Store，这个文件是MAC的finder文件，可以隐藏显示:1.preference - &gt; setting -&gt; core 中，找到Ignored Names，在其中添加 .DS_Store，注意添加”,”2.在packages中搜索”tree-view” 在其设置中，勾选 Hide Ignored Names 这里列出几种常用插件：color-picker : 取色器 快捷键：cmd+shift+cRIB - run in browser: 浏览器预览 快捷键：ctrl+alt +rgit-plus :git的快捷键: Cmd-Shift-Hatom-ternjs: JS代码智能补全CSScomb :css美化atom-beautify: atom美化代码，可以在保存的时候自动格式化alt-cmd-i :chrome调试","tags":[{"name":"前端","slug":"前端","permalink":"http://139.129.18.59/tags/前端/"},{"name":"工具","slug":"工具","permalink":"http://139.129.18.59/tags/工具/"}]},{"title":"CSS3 transition实现图片旋转","date":"2016-11-24T14:10:06.000Z","path":"2016/11/24/css图片旋转/","text":"在CSS3中，实现旋转效果需要用到transform属性中的rotate属性；实现盒阴影效果需要使用box-shadow属性。具体参见下面的示例代码。 -webkit-transform:rotate(10deg); -moz-transform:rotate(10deg); transform:rotate(10deg); -webkit-box-shadow:2px 2px 3px rgba(135, 139, 144, 0.4); -moz-box-shadow:2px 2px 3px rgba(135, 139, 144, 0.4); box-shadow:2px 2px 3px rgba(135, 139, 144, 0.4); 上面代码部分，首先应该知道的是webkit表示webkit核心的浏览器，是其私有属性，作用于chrome和Safari浏览器，moz是Firefox浏览器的私有属性。transform中文意思转换，含有多个属性值，其中rotate表示旋转，其他一些属性如scale-尺寸放大缩小（本文将会用到），skew表示倾斜角度，translate表移动距离。例如，本例中，rotate(10deg)表示顺时针旋转10度，如果要逆时针旋转，使用负值就可以了。box-shadow表示盒阴影，其有四个参数，第一个参数表示水平偏移，例如2px表示投影右偏移2像素，第二个参数表示垂直偏移，2px表示投影向下偏移2像素，第三个参数表示模糊的大小，第四个参数为rgba颜色值，例如 rgba(135, 139, 144, 0.4)，括号内四个值分别指代r(red),g(green),b(blue),a(opacity)，这里表示透明度为40%的一种灰色。 增加动画效果CSS代码： .pic{ display:block; width:256px; margin:60px 0 0; padding:10px 10px 15px; text-align:center; background:white; border:1px solid #bfbfbf; -webkit-transform:rotate(10deg); -moz-transform:rotate(10deg); transform:rotate(10deg); -webkit-box-shadow:2px 2px 3px rgba(135, 139, 144, 0.4); -moz-box-shadow:2px 2px 3px rgba(135, 139, 144, 0.4); box-shadow:2px 2px 3px rgba(135, 139, 144, 0.4); -webkit-transition:all 0.5s ease-in; } .pic:hover,.pic:focus,.pic:active{ border-color:#9a9a9a; -webkit-transform:rotate(0deg); -moz-transform:rotate(0deg); transform:rotate(0deg); } 代码部分最关键的就是：-webkit-transition:all 0.5s ease-in;目前而言，transition仅webkit核心的浏览器支持，所以此效果仅在chrome或是Safari下有。transiton属性有这几个值：transition-property: //指定过渡的性质，比如transition-property:backgrond 就是只指定backgound参与这个过渡transition-duration://指定这个过渡的持续时间transition-delay: //延迟过渡时间transition-timing-function://指定过渡类型，有ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier 熟悉flash显示与动画编程的应该知道，这里的过渡类型的含义与flash中缓动类型（远不及flash丰富）是一致的：linear //线性过度ease-in //由慢到快ease-out //由快到慢ease-in-out //由慢到快在到慢 所以，-webkit-transition:all 0.5s ease-in表示的意思就是所有的属性都执行过渡效果，像角度啊，投影大小，边框色或是下面要讲到的比例啦等，执行时间为0.5秒，过渡动画类型为先慢后快。","tags":[{"name":"前端css","slug":"前端css","permalink":"http://139.129.18.59/tags/前端css/"},{"name":"图片旋转","slug":"图片旋转","permalink":"http://139.129.18.59/tags/图片旋转/"}]},{"title":"nginx挂载软连接的问题","date":"2016-11-24T14:10:06.000Z","path":"2016/11/24/nginx挂载软连接的问题/","text":"问题：在nginx的html文件目录挂载了一个软连接，发现通过nginx访问始终是403，访问限制。后来查询google发现原因是nginx对软连接进行访问限制，没有办法通过nginx去访问。解决：取消软连接，利用nfs挂载文件这里实际服务器为例子。执行命令： mount -l 发现没有挂载，所以执行mount命令将文件路径挂载到nginx的html下面即可。 mount 10.10.1.151:/opt/emm/uploads /usr/share/nginx/html 随后 vim /etc/fstab 看到没有记录，这样每次服务器重启后挂载就会消失。这里修改下文件： 10.10.1.151:/opt/emm /opt/emm nfs defaults 0 0 10.10.1.151:/opt/emm/uploads /usr/share/nginx/uploads nfs defaults 0 0 退出保存修改。 然后执行命令查看： mount -a 挂载成功。","tags":[{"name":"后端","slug":"后端","permalink":"http://139.129.18.59/tags/后端/"},{"name":"nginx","slug":"nginx","permalink":"http://139.129.18.59/tags/nginx/"}]},{"title":"PhotoSwipe中文API","date":"2016-11-23T04:10:06.000Z","path":"2016/11/23/相册js/","text":"PhotoSwipe 是专为移动触摸设备设计的相册/画廊.兼容所有iPhone、iPad、黑莓6+,以及桌面浏览器.底层实现基于HTML/CSS/JavaScript,是一款免费开源的相册产品 入门开始之前你应该知道的第一件事: PhotoSwipe不是一个简单的jQuery插件，至少需要基本的JavaScript知识来安装。 PhotoSwipe需要预先定义的图片尺寸（更多相关信息）。 如果您在非响应网站上使用PhotoSwipe，则控件将在移动设备上进行缩放（整个页面缩放）。因此，您需要实现自定义控件（例如右上角的单个大关闭按钮）。 文档中的所有代码都是纯Vanilla JS，并支持IE 8及更高版本。如果您的网站或应用程序使用一些JavaScript框架（如jQuery或MooTools）或您不需要支持旧的浏览器 - 随意简化代码。 避免为移动设备投放大图片（大于2000x1500像素），因为它们会大大降低动画效果，并可能导致崩溃（尤其是在iOS Safari上）。可能的解决方案：提供响应图像，或在单独的页面上打开图像，或使用支持图像平铺的库（如传单）（更多在常见问题）。初始化步骤1：包括JS和CSS文件你可以找到他们DIST /文件夹的GitHub存储库。Sass和未编译的JS文件位于文件夹src/中。如果您计划修改现有样式，我建议使用Sass，因为代码是结构化的和注释的。 &lt;!-- Core CSS file --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/photoswipe.css&quot;&gt; &lt;!-- Skin CSS file (styling of UI - buttons, caption, etc.) In the folder of skin CSS file there are also: - .png and .svg icons sprite, - preloader.gif (for browsers that do not support CSS animations) --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/default-skin/default-skin.css&quot;&gt; &lt;!-- Core JS file --&gt; &lt;script src=&quot;path/to/photoswipe.min.js&quot;&gt;&lt;/script&gt; &lt;!-- UI JS file --&gt; &lt;script src=&quot;path/to/photoswipe-ui-default.min.js&quot;&gt;&lt;/script&gt; 不管你如何和在哪里将包括JS和CSS文件。代码只有在您调用时才会执行new PhotoSwipe()。所以，如果你不需要PhotoSwipe最初打开，随意推迟文件加载。PhotoSwipe还支持AMD加载器（如RequireJS）和CommonJS，使用它们像这样： require([ &#39;path/to/photoswipe.js&#39;, &#39;path/to/photoswipe-ui-default.js&#39; ], function( PhotoSwipe, PhotoSwipeUI_Default ) { // var gallery = new PhotoSwipe( someElement, PhotoSwipeUI_Default ... // gallery.init() // ... }); 此外，您可以通过Bower（bower install photoswipe）或NPM（npm install photoswipe）安装它。 步骤2：向DOM中添加PhotoSwipe（.pswp）元素您可以通过JS动态添加HTML代码（直接在初始化之前），或者在页面中初始化（像在演示页面上完成）。这个代码可以追加到任何地方，但最好是在关闭之前。您可以在多个库中重复使用它（只要使用相同的UI类）。 &lt;!-- Root element of PhotoSwipe. Must have class pswp. --&gt; &lt;div class=&quot;pswp&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-hidden=&quot;true&quot;&gt; &lt;!-- Background of PhotoSwipe. It&#39;s a separate element as animating opacity is faster than rgba(). --&gt; &lt;div class=&quot;pswp__bg&quot;&gt;&lt;/div&gt; &lt;!-- Slides wrapper with overflow:hidden. --&gt; &lt;div class=&quot;pswp__scroll-wrap&quot;&gt; &lt;!-- Container that holds slides. PhotoSwipe keeps only 3 of them in the DOM to save memory. Don&#39;t modify these 3 pswp__item elements, data is added later on. --&gt; &lt;div class=&quot;pswp__container&quot;&gt; &lt;div class=&quot;pswp__item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pswp__item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pswp__item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. --&gt; &lt;div class=&quot;pswp__ui pswp__ui--hidden&quot;&gt; &lt;div class=&quot;pswp__top-bar&quot;&gt; &lt;!-- Controls are self-explanatory. Order can be changed. --&gt; &lt;div class=&quot;pswp__counter&quot;&gt;&lt;/div&gt; &lt;button class=&quot;pswp__button pswp__button--close&quot; title=&quot;Close (Esc)&quot;&gt;&lt;/button&gt; &lt;button class=&quot;pswp__button pswp__button--share&quot; title=&quot;Share&quot;&gt;&lt;/button&gt; &lt;button class=&quot;pswp__button pswp__button--fs&quot; title=&quot;Toggle fullscreen&quot;&gt;&lt;/button&gt; &lt;button class=&quot;pswp__button pswp__button--zoom&quot; title=&quot;Zoom in/out&quot;&gt;&lt;/button&gt; &lt;!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR --&gt; &lt;!-- element will get class pswp__preloader--active when preloader is running --&gt; &lt;div class=&quot;pswp__preloader&quot;&gt; &lt;div class=&quot;pswp__preloader__icn&quot;&gt; &lt;div class=&quot;pswp__preloader__cut&quot;&gt; &lt;div class=&quot;pswp__preloader__donut&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;pswp__share-modal pswp__share-modal--hidden pswp__single-tap&quot;&gt; &lt;div class=&quot;pswp__share-tooltip&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;button class=&quot;pswp__button pswp__button--arrow--left&quot; title=&quot;Previous (arrow left)&quot;&gt; &lt;/button&gt; &lt;button class=&quot;pswp__button pswp__button--arrow--right&quot; title=&quot;Next (arrow right)&quot;&gt; &lt;/button&gt; &lt;div class=&quot;pswp__caption&quot;&gt; &lt;div class=&quot;pswp__caption__center&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; pswp__bg，pswp__scroll-wrap，pswp__container和pswp__item元件的顺序不应被改变。你可能会问，为什么PhotoSwipe不通过JS自动添加这个代码，原因很简单 - 只是为了保存文件大小，万一你需要一些修改布局。 步骤3：初始化执行PhotoSwipe构造函数。它接受4个参数：1、.pswp元素（必须添加到DOM）。2、PhotoSwipe UI类。如果你包含默认photoswipe-ui-default.js，类将会PhotoSwipeUI_Default。可以false。3、具有对象的数组（幻灯片）。4、选项。 var pswpElement = document.querySelectorAll(&#39;.pswp&#39;)[0]; // build items array var items = [ { src: &#39;https://placekitten.com/600/400&#39;, w: 600, h: 400 }, { src: &#39;https://placekitten.com/1200/900&#39;, w: 1200, h: 900 } ]; // define options (if needed) var options = { // optionName: &#39;option value&#39; // for example: index: 0 // start at first slide }; // Initializes and opens PhotoSwipe var gallery = new PhotoSwipe( pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); 最后你应该得到这样的东西：HTML代码: &lt;button id=&quot;btn&quot;&gt;Open PhotoSwipe&lt;/button&gt; &lt;!-- Root element of PhotoSwipe. Must have class pswp. --&gt; &lt;div class=&quot;pswp&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-hidden=&quot;true&quot;&gt; &lt;!-- Background of PhotoSwipe. It&#39;s a separate element, as animating opacity is faster than rgba(). --&gt; &lt;div class=&quot;pswp__bg&quot;&gt;&lt;/div&gt; &lt;!-- Slides wrapper with overflow:hidden. --&gt; &lt;div class=&quot;pswp__scroll-wrap&quot;&gt; &lt;!-- Container that holds slides. PhotoSwipe keeps only 3 slides in DOM to save memory. --&gt; &lt;div class=&quot;pswp__container&quot;&gt; &lt;!-- don&#39;t modify these 3 pswp__item elements, data is added later on --&gt; &lt;div class=&quot;pswp__item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pswp__item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pswp__item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. --&gt; &lt;div class=&quot;pswp__ui pswp__ui--hidden&quot;&gt; &lt;div class=&quot;pswp__top-bar&quot;&gt; &lt;!-- Controls are self-explanatory. Order can be changed. --&gt; &lt;div class=&quot;pswp__counter&quot;&gt;&lt;/div&gt; &lt;button class=&quot;pswp__button pswp__button--close&quot; title=&quot;Close (Esc)&quot;&gt;&lt;/button&gt; &lt;button class=&quot;pswp__button pswp__button--share&quot; title=&quot;Share&quot;&gt;&lt;/button&gt; &lt;button class=&quot;pswp__button pswp__button--fs&quot; title=&quot;Toggle fullscreen&quot;&gt;&lt;/button&gt; &lt;button class=&quot;pswp__button pswp__button--zoom&quot; title=&quot;Zoom in/out&quot;&gt;&lt;/button&gt; &lt;!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR --&gt; &lt;!-- element will get class pswp__preloader--active when preloader is running --&gt; &lt;div class=&quot;pswp__preloader&quot;&gt; &lt;div class=&quot;pswp__preloader__icn&quot;&gt; &lt;div class=&quot;pswp__preloader__cut&quot;&gt; &lt;div class=&quot;pswp__preloader__donut&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;pswp__share-modal pswp__share-modal--hidden pswp__single-tap&quot;&gt; &lt;div class=&quot;pswp__share-tooltip&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;button class=&quot;pswp__button pswp__button--arrow--left&quot; title=&quot;Previous (arrow left)&quot;&gt; &lt;/button&gt; &lt;button class=&quot;pswp__button pswp__button--arrow--right&quot; title=&quot;Next (arrow right)&quot;&gt; &lt;/button&gt; &lt;div class=&quot;pswp__caption&quot;&gt; &lt;div class=&quot;pswp__caption__center&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; JS代码： var openPhotoSwipe = function() { var pswpElement = document.querySelectorAll(&#39;.pswp&#39;)[0]; // build items array var items = [ { src: &#39;https://farm2.staticflickr.com/1043/5186867718_06b2e9e551_b.jpg&#39;, w: 964, h: 1024 }, { src: &#39;https://farm7.staticflickr.com/6175/6176698785_7dee72237e_b.jpg&#39;, w: 1024, h: 683 } ]; // define options (if needed) var options = { // history &amp; focus options are disabled on CodePen history: false, focus: false, showAnimationDuration: 0, hideAnimationDuration: 0 }; var gallery = new PhotoSwipe( pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); }; openPhotoSwipe(); document.getElementById(&#39;btn&#39;).onclick = openPhotoSwipe; 创建幻灯片对象数组数组中的每个对象都应包含有关幻灯片的数据，它可以是您想要在PhotoSwipe中显示的任何内容 - 图片路径，字幕字符串，共享数量，评论等。默认情况下，PhotoSwipe仅使用5个属性：（src路径到图像），w（图像宽度），h（图像高度），msrc（小图像占位符的路径，大图像将被加载在顶部），html（自定义HTML，更多关于它）。在导航期间，PhotoSwipe会向此对象添加自己的属性（如minZoom或loaded） var slides = [ // slide 1 { src: &#39;path/to/image1.jpg&#39;, // path to image w: 1024, // image width h: 768, // image height msrc: &#39;path/to/small-image.jpg&#39;, // small image placeholder, // main (large) image loads on top of it, // if you skip this parameter - grey rectangle will be displayed, // try to define this property only when small image was loaded before title: &#39;Image Caption&#39; // used by Default PhotoSwipe UI // if you skip it, there won&#39;t be any caption // You may add more properties here and use them. // For example, demo gallery uses &quot;author&quot; property, which is used in the caption. // author: &#39;John Doe&#39; }, // slide 2 { src: &#39;path/to/image2.jpg&#39;, w: 600, h: 600 // etc. } // etc. ]; 您可以在PhotoSwipe读取它们之前直接动态定义幻灯片对象属性，使用gettingData事件（更多信息在文档的API部分）。例如，该技术可以用于为不同的屏幕尺寸提供不同的图像。 如何从链接列表构建幻灯片数组假设您有一个看起来像这样的链接/缩略图列表（关于图库标记的更多信息）： &lt;div class=&quot;my-gallery&quot; itemscope itemtype=&quot;http://schema.org/ImageGallery&quot;&gt; &lt;figure itemprop=&quot;associatedMedia&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt; &lt;a href=&quot;large-image.jpg&quot; itemprop=&quot;contentUrl&quot; data-size=&quot;600x400&quot;&gt; &lt;img src=&quot;small-image.jpg&quot; itemprop=&quot;thumbnail&quot; alt=&quot;Image description&quot; /&gt; &lt;/a&gt; &lt;figcaption itemprop=&quot;caption description&quot;&gt;Image caption&lt;/figcaption&gt; &lt;/figure&gt; &lt;figure itemprop=&quot;associatedMedia&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt; &lt;a href=&quot;large-image.jpg&quot; itemprop=&quot;contentUrl&quot; data-size=&quot;600x400&quot;&gt; &lt;img src=&quot;small-image.jpg&quot; itemprop=&quot;thumbnail&quot; alt=&quot;Image description&quot; /&gt; &lt;/a&gt; &lt;figcaption itemprop=&quot;caption description&quot;&gt;Image caption&lt;/figcaption&gt; &lt;/figure&gt; &lt;/div&gt; …并且您想要点击缩略图以大图片打开PhotoSwipe（就像在演示页上完成的一样）。所有你需要做的是：1、将点击事件绑定到链接/缩略图。2、用户点击缩略图后，找到其索引。3、从DOM元素创建幻灯片对象数组 - 循环遍历所有链接并检索href属性（大图片网址），data-size属性（其大小），src缩略图和标题内容。PhotoSwipe真的不在乎你会怎么做。如果你使用jQuery或MooTools等框架，或者如果你不需要支持IE8，代码可以大大简化。这里是纯IE的支持的vanilla JS实现： var initPhotoSwipeFromDOM = function(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function(el) { var thumbElements = el.childNodes, numNodes = thumbElements.length, items = [], figureEl, linkEl, size, item; for(var i = 0; i &lt; numNodes; i++) { figureEl = thumbElements[i]; // &lt;figure&gt; element // include only element nodes if(figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // &lt;a&gt; element size = linkEl.getAttribute(&#39;data-size&#39;).split(&#39;x&#39;); // create slide object item = { src: linkEl.getAttribute(&#39;href&#39;), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if(figureEl.children.length &gt; 1) { // &lt;figcaption&gt; content item.title = figureEl.children[1].innerHTML; } if(linkEl.children.length &gt; 0) { // &lt;img&gt; thumbnail element, retrieving thumbnail url item.msrc = linkEl.children[0].getAttribute(&#39;src&#39;); } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el &amp;&amp; ( fn(el) ? el : closest(el.parentNode, fn) ); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return (el.tagName &amp;&amp; el.tagName.toUpperCase() === &#39;FIGURE&#39;); }); if(!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, childNodes = clickedListItem.parentNode.childNodes, numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i &lt; numChildNodes; i++) { if(childNodes[i].nodeType !== 1) { continue; } if(childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if(index &gt;= 0) { // open PhotoSwipe if valid index found openPhotoSwipe( index, clickedGallery ); } return false; }; // parse picture index and gallery index from URL (#&amp;pid=1&amp;gid=2) var photoswipeParseHash = function() { var hash = window.location.hash.substring(1), params = {}; if(hash.length &lt; 5) { return params; } var vars = hash.split(&#39;&amp;&#39;); for (var i = 0; i &lt; vars.length; i++) { if(!vars[i]) { continue; } var pair = vars[i].split(&#39;=&#39;); if(pair.length &lt; 2) { continue; } params[pair[0]] = pair[1]; } if(params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll(&#39;.pswp&#39;)[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute(&#39;data-pswp-uid&#39;), getThumbBoundsFn: function(index) { // See Options -&gt; getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName(&#39;img&#39;)[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return {x:rect.left, y:rect.top + pageYScroll, w:rect.width}; } }; // PhotoSwipe opened from URL if(fromURL) { if(options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for(var j = 0; j &lt; items.length; j++) { if(items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if( isNaN(options.index) ) { return; } if(disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe( pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll( gallerySelector ); for(var i = 0, l = galleryElements.length; i &lt; l; i++) { galleryElements[i].setAttribute(&#39;data-pswp-uid&#39;, i+1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&amp;pid=3&amp;gid=1 var hashData = photoswipeParseHash(); if(hashData.pid &amp;&amp; hashData.gid) { openPhotoSwipe( hashData.pid , galleryElements[ hashData.gid - 1 ], true, true ); } }; // execute above function initPhotoSwipeFromDOM(&#39;.my-gallery&#39;); 提示：您可以从CodePen下载示例以在本地播放（Edit on CodePen- &gt; Share- &gt; Export .zip）。如果您使用的标记与此示例不同，则需要编辑功能parseThumbnailElements。如果你没有纯粹的JavaScript经验，并且不知道如何解析DOM，请参考QuirksMode和MDN上的文档。请注意，IE8不支持HTML5和元素，因此您需要在节中包含html5shiv（cdnjs托管版本用于示例）：","tags":[{"name":"相册","slug":"相册","permalink":"http://139.129.18.59/tags/相册/"},{"name":"PhotoSwipe","slug":"PhotoSwipe","permalink":"http://139.129.18.59/tags/PhotoSwipe/"}]},{"title":"tomcat的部署","date":"2016-11-15T05:10:06.000Z","path":"2016/11/15/备用/tomcat的部署/","text":"安装tomcat需要预先安装JDK, JDK安装方法参考如下文档：http://help.aliyun.com/knowledge_detail/6507861.html?spm=5176.7114037.1996646101.1.FD0keL&amp;pos=1 本文将tomcat安装到了/usr/local/jdk1.8.0_60目录下，如果安装到了其他目录，请替换掉本文的JDK目录。 1. 下载tomcat：#wget http://apache.fayea.com/tomcat/tomcat-7/v7.0.64/bin/apache-tomcat-7.0.64.tar.gz 如果下载404，重新找路径apache.fayea.com/tomcat/tomcat-7/v7.0.69/bin/apache-tomcat-7.0.69.tar.gz 2. 将tomcat放置到 /usr/local/ 目录下#mv apache-tomcat-7.0.64.tar.gz /usr/local/ 3. 解压缩：tar -xvzf /usr/local/apache-tomcat-7.0.64.tar.gz 4. 设置tomcat开机自启动编辑/usr/local/apache-tomcat-7.0.64.tar.gz/bin/startup.sh # vi /usr/local/apache-tomcat-7.0.64/bin/startup.sh 加入如下行： #chkconfig: 2345 80 90 #description:tomcat auto start #processname: tomcat 编辑/usr/local/apache-tomcat-7.0.64/bin/catalina.sh # vi /usr/local/apache-tomcat-7.0.64/bin/catalina.sh 搜索export关键字，加入如下行： export CATALINA_BASE=/usr/local/apache-tomcat-7.0.64 export CATALINA_HOME=/usr/local/apache-tomcat-7.0.64 export CATALINA_TMPDIR=/usr/local/apache-tomcat-7.0.64 将tomcat加入开机自启动 # vi /etc/rc.d/rc.local 加入如下内容： export JAVA_HOME=/usr/local/jdk1.8.0_60 /usr/local/apache-tomcat-7.0.64/bin/startup.sh start 执行 # /usr/local/apache-tomcat-7.0.64/bin/startup.sh 启动tomcat 打开浏览器测试：tomcat默认监听8080端口，如果要修改成为80端口，按如下步骤修改： # vi /usr/local/apache-tomcat-7.0.64/conf/server.xml 找到 &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; &lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 修改为： &lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; &lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 重启tomcat生效","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://139.129.18.59/tags/tomcat/"}]},{"title":"hexo同步到github","date":"2016-11-15T04:10:06.000Z","path":"2016/11/15/hexo同步到github/","text":"上传本地项目到github 建立Git仓库git init 将项目文件添加到仓库中git add . 注意：add后面有个 . 将我们添加的文件commit到git仓库， 添加注释git commit -m &quot;注释&quot; 将本地的仓库与github上的仓库进行关联 git remote add origin &quot;git仓库的地址&quot; 在这个工程中可能要求你输入账户密码，我们先保存ssh密钥在git上，使用git协议的地址就不会要求你输入了。 上传之前我们先从git上拉取一下 git pull origin master push本地项目到远程仓库git push -u origin master 至此项目就上传到github上了。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://139.129.18.59/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://139.129.18.59/tags/github/"}]},{"title":"NFS安装配置","date":"2016-11-15T04:10:06.000Z","path":"2016/11/15/NFS安装配置/","text":"一、NFS服务简介 NFS 是Network File System的缩写，即网络文件系统。一种使用于分散式文件系统的协定，由Sun公司开发，于1984年向外公布。功能是通过网络让不同的机器、不同的操作系统能够彼此分享个别的数据，让应用程序在客户端通过网络访问位于服务器磁盘中的数据，是在类Unix系统间实现磁盘文件共享的一种方法。 NFS 的基本原则是“容许不同的客户端及服务端通过一组RPC分享相同的文件系统”，它是独立于操作系统，容许不同硬件及操作系统的系统共同进行文件的分享。 NFS在文件传送或信息传送过程中依赖于RPC协议。RPC，远程过程调用 (Remote Procedure Call) 是能使客户端执行其他系统中程序的一种机制。NFS本身是没有提供信息传输的协议和功能的，但NFS却能让我们通过网络进行资料的分享，这是因为NFS使用了一些其它的传输协议。而这些传输协议用到这个RPC功能的。可以说NFS本身就是使用RPC的一个程序。或者说NFS也是一个RPC SERVER。所以只要用到NFS的地方都要启动RPC服务，不论是NFS SERVER或者NFS CLIENT。这样SERVER和CLIENT才能通过RPC来实现PROGRAM PORT的对应。可以这么理解RPC和NFS的关系：NFS是一个文件系统，而RPC是负责负责信息的传输。 二、系统环境系统平台：CentOS release 5.6 (Final) NFS Server IP：192.168.1.108 防火墙已关闭/iptables: Firewall is not running. SELINUX=disabled 三、检查安装NFS服务（旧版linux安装）NFS的安装是非常简单的，只需要两个软件包即可，而且在通常情况下，是作为系统的默认包安装的。 nfs-utils- * ：包括基本的NFS命令与监控程序 portmap- * ：支持安全NFS RPC服务的连接1、查看系统是否已安装NFS[cttq@ainewdev ~]$ rpm -qa|grep nfs nfs4-acl-tools-0.3.3-8.el6.x86_64 nfs-utils-1.2.3-70.el6_8.2.x86_64 nfs-utils-lib-1.1.5-11.el6.x86_64 [cttq@ainewdev ~]$ rpm -qa|grep portmap 系统默认已安装了nfs-utils portmap 两个软件包。 2、如果当前系统中没有安装NFS所需的软件包，需要手工进行安装。nfs-utils 和portmap 两个包的安装文件在系统光盘中都会有。# mount /dev/cdrom /mnt/cdrom/ # cd /mnt/cdrom/CentOS/ # rpm -ivh portmap-4.0-65.2.2.1.i386.rpm # rpm -ivh nfs-utils-1.0.9-50.el5.i386.rpm # rpm -q nfs-utils portmap 检查的时候发现portmap不存在，命令 more /etc/issue 查看当前系统版本：CentOS release 6.8 上面的portmap服务在centos 6.4中已经被rpcbind取代，所以采用下面的检查安装方法：。 1、检查系统是否开启nfs服务：service nfs status 结果显示nfs: unrecognized service，说明系统没有安装nfs服务,so 安装之；注意，yum install nfs是无法安装的，应该用yum install nfs-utils. 2、检查是否开启rpcbind服务：service rpcbind status发现已经在nfs-utils的时候一起安装了。总结：yum install nfs-utils 四、NFS系统守护进程 nfsd：它是基本的NFS守护进程，主要功能是管理客户端是否能够登录服务器； mountd：它是RPC安装守护进程，主要功能是管理NFS的文件系统。当客户端顺利通过nfsd登录NFS服务器后，在使用NFS服务所提供的文件前，还必须通过文件使用权限的验证。它会读取NFS的配置文件/etc/exports来对比客户端权限。 portmap：主要功能是进行端口映射工作。当客户端尝试连接并使用RPC服务器提供的服务（如NFS服务）时，portmap会将所管理的与服务对应的端口提供给客户端，从而使客户可以通过该端口向服务器请求服务。五、NFS服务器的配置 NFS服务器的配置相对比较简单，只需要在相应的配置文件中进行设置，然后启动NFS服务器即可。 NFS的常用目录: /etc/exports NFS服务的主要配置文件/usr/sbin/exportfs NFS服务的管理命令/usr/sbin/showmount 客户端的查看命令/var/lib/nfs/etab 记录NFS分享出来的目录的完整权限设定值/var/lib/nfs/xtab 记录曾经登录过的客户端信息NFS服务的配置文件为 /etc/exports，这个文件是NFS的主要配置文件，不过系统并没有默认值，所以这个文件不一定会存在，可能要使用vim手动建立，然后在文件里面写入配置内容。 /etc/exports文件内容格式： &lt;输出目录&gt; [客户端1 选项（访问权限,用户映射,其他）] [客户端2 选项（访问权限,用户映射,其他）] a. 输出目录：输出目录是指NFS系统中需要共享给客户机使用的目录； b. 客户端：客户端是指网络中可以访问这个NFS输出目录的计算机 客户端常用的指定方式 指定ip地址的主机：192.168.0.200 指定子网中的所有主机：192.168.0.0/24 192.168.0.0/255.255.255.0 指定域名的主机：david.bsmart.cn 指定域中的所有主机：*.bsmart.cn 所有主机：* c. 选项：选项用来设置输出目录的访问权限、用户映射等。 NFS主要有3类选项： 访问权限选项 设置输出目录只读：ro 设置输出目录读写：rw用户映射选项 all_squash：将远程访问的所有普通用户及所属组都映射为匿名用户或用户组（nfsnobody）； no_all_squash：与all_squash取反（默认设置）； root_squash：将root用户及所属组都映射为匿名用户或用户组（默认设置）； no_root_squash：与rootsquash取反； anonuid=xxx：将远程访问的所有用户都映射为匿名用户，并指定该用户为本地用户（UID=xxx）； anongid=xxx：将远程访问的所有用户组都映射为匿名用户组账户，并指定该匿名用户组账户为本地用户组账户（GID=xxx）；其它选项 secure：限制客户端只能从小于1024的tcp/ip端口连接nfs服务器（默认设置）； insecure：允许客户端从大于1024的tcp/ip端口连接服务器； sync：将数据同步写入内存缓冲区与磁盘中，效率低，但可以保证数据的一致性； async：将数据先保存在内存缓冲区中，必要时才写入磁盘； wdelay：检查是否有相关的写操作，如果有则将这些写操作一起执行，这样可以提高效率（默认设置）； no_wdelay：若有写操作则立即执行，应与sync配合使用； subtree：若输出目录是一个子目录，则nfs服务器将检查其父目录的权限(默认设置)； no_subtree：即使输出目录是一个子目录，nfs服务器也不检查其父目录的权限，这样可以提高效率； 六、NFS服务器的启动与停止在对exports文件进行了正确的配置后，就可以启动NFS服务器了。 1、启动NFS服务器为了使NFS服务器能正常工作，需要启动portmap和nfs两个服务，并且portmap一定要先于nfs启动。 # service rpcbind start # service nfs start 2、查询NFS服务器状态# service rpcbind status # service nfs status 3、停止NFS服务器要停止NFS运行时，需要先停止nfs服务再停止portmap服务，对于系统中有其他服务(如NIS)需要使用时，不需要停止portmap服务 # service nfs stop # service rpcbind stop 4、设置NFS服务器的自动启动状态对于实际的应用系统，每次启动LINUX系统后都手工启动nfs服务器是不现实的，需要设置系统在指定的运行级别自动启动portmap(rpcbind)和nfs服务。 # chkconfig --list rpcbind # chkconfig --list nfs 设置portmap和nfs服务在系统运行级别3和5自动启动。 # chkconfig --level 35 portmap on # chkconfig --level 35 nfs on 七、实例1、将NFS Server 的/home/david/ 共享给192.168.1.0/24网段，权限读写。服务器端文件详细如下： # vi /etc/exports /home/david 192.168.1.0/24(rw) 2、重启portmap 和nfs 服务# service portmap restart # service nfs restart # exportfs 3、服务器端使用showmount命令查询NFS的共享状态# showmount -e //默认查看自己共享的服务，前提是要DNS能解析自己，不然容易报错 # showmount -a //显示已经与客户端连接上的目录信息 4、客户端使用showmount命令查询NFS的共享状态# showmount -e NFS服务器IP 5、客户端挂载NFS服务器中的共享目录命令格式 # mount NFS服务器IP:共享目录 本地挂载点目录 # mount 192.168.1.108:/home/david/ /tmp/david/ # mount |grep nfs 挂载成功。 查看文件是否和服务器端一致。 6、NFS的共享权限和访问控制现在我们在/tmp/david/ 里面建立一个文件，看看权限是什么 # touch 20130103 这里出现Permission denied，是因为NFS 服务器端共享的目录本身的写权限没有开放给其他用户，在服务器端打开该权限。 # chmod 777 -R /home/david/ 再次在客户端/tmp/david/ 里面建立一个文件 我用root 用户建立的文件，变成了nfsnobody 用户。 NFS有很多默认的参数，打开/var/lib/nfs/etab 查看分享出来的/home/david/ 完整权限设定值。 # cat /var/lib/nfs/etab 默认就有sync，wdelay，hide 等等，no_root_squash 是让root保持权限，root_squash 是把root映射成nobody，no_all_squash 不让所有用户保持在挂载目录中的权限。所以，root建立的文件所有者是nfsnobody。 下面我们使用普通用户挂载、写入文件测试。 # su - david $ cd /tmp/david/ $ touch 2013david 普通用户写入文件时就是自己的名字，这也就保证了服务器的安全性。关于权限的分析 1. 客户端连接时候，对普通用户的检查 a. 如果明确设定了普通用户被压缩的身份，那么此时客户端用户的身份转换为指定用户； b. 如果NFS server上面有同名用户，那么此时客户端登录账户的身份转换为NFS server上面的同名用户； c. 如果没有明确指定，也没有同名用户，那么此时 用户身份被压缩成nfsnobody； 2. 客户端连接的时候，对root的检查 a. 如果设置no_root_squash，那么此时root用户的身份被压缩为NFS server上面的root； b. 如果设置了all_squash、anonuid、anongid，此时root 身份被压缩为指定用户； c. 如果没有明确指定，此时root用户被压缩为nfsnobody； d. 如果同时指定no_root_squash与all_squash 用户将被压缩为 nfsnobody，如果设置了anonuid、anongid将被压缩到所指定的用户与组； 7、卸载已挂载的NFS共享目录# umount /tmp/david/ 八、启动自动挂载nfs文件系统格式： &lt;server&gt;:&lt;/remote/export&gt; &lt;/local/directory&gt; nfs &lt; options&gt; 0 0 # vi /etc/fstab 保存退出，重启系统。 查看/home/david 有没有自动挂载。 自动挂载成功。 九、相关命令1、exportfs 如果我们在启动了NFS之后又修改了/etc/exports，是不是还要重新启动nfs呢？这个时候我们就可以用exportfs 命令来使改动立刻生效，该命令格式如下： # exportfs [-aruv] -a 全部挂载或卸载 /etc/exports中的内容 -r 重新读取/etc/exports 中的信息 ，并同步更新/etc/exports、/var/lib/nfs/xtab -u 卸载单一目录（和-a一起使用为卸载所有/etc/exports文件中的目录） -v 在export的时候，将详细的信息输出到屏幕上。 具体例子： # exportfs -au 卸载所有共享目录 # exportfs -rv 重新共享所有目录并输出详细信息 2、nfsstat 查看NFS的运行状态，对于调整NFS的运行有很大帮助。 3、rpcinfo 查看rpc执行信息，可以用于检测rpc运行情况的工具，利用rpcinfo -p 可以查看出RPC开启的端口所提供的程序有哪些。 4、showmount -a 显示已经于客户端连接上的目录信息 -e IP或者hostname 显示此IP地址分享出来的目录 5、netstat 可以查看出nfs服务开启的端口，其中nfs 开启的是2049，portmap 开启的是111，其余则是rpc开启的。 最后注意两点，虽然通过权限设置可以让普通用户访问，但是挂载的时候默认情况下只有root可以去挂载，普通用户可以执行sudo。 NFS server 关机的时候一点要确保NFS服务关闭，没有客户端处于连接状态！通过showmount -a 可以查看，如果有的话用kill killall pkill 来结束，（-9 强制结束） CentOS 6.3下Samba服务器的安装与配置http://www.cnblogs.com/mchina/archive/2012/12/18/2816717.html","tags":[{"name":"nfs","slug":"nfs","permalink":"http://139.129.18.59/tags/nfs/"}]},{"title":"hexo发布文章注意","date":"2016-11-14T03:10:06.000Z","path":"2016/11/14/hexo配置注意的地方/","text":"注意点1：发布的时候,检查_config.yml内容，特别注意:后面需要有一个空格：tags: markdown不然会报错：can not read a block mapping entry; a multiline key may not be an implicit key","tags":[{"name":"hexo","slug":"hexo","permalink":"http://139.129.18.59/tags/hexo/"}]},{"title":"hexo部署和自动化发布","date":"2016-11-14T03:10:06.000Z","path":"2016/11/14/hexo自动化/","text":"这里安装hexo过程省略，参考其他文章。这里主要说下如何利用git自动化发布： 安装git：sudo apt-get install git 创建GitHub Repository ，在git上创建一个reop库，取名hexo_static 安装插件 $ npm install hexo-deployer-git --save 修改配置文件 deploy: type: git repo: git@github.com:$username/hexo_static.git branch: master 注意替换username为自己的git名字，注意这里如果使用https协议的git，那么每次都会要求输入账户和密码，这里使用git协议，在ssh里保存密钥，这样不用每次都输入密码 执行命令 $ hexo generate $ hexo deploy generate: 生成静态文件，文件生成在pulic目录下deploy: 发布到git的库hexo_static 实现自动化 这里实现自动化思路：通过git –bare 生成一个裸库bare，裸库bare作为一个远程库remote，在裸库实现一个钩子post-receive，当本地库进行push的时候，自动运行钩子，从而更新静态文件目录A，使用nginx进行转发到静态文件目录A。 第1步：初始化空仓库 $ git init --bare ~/hexo_bare 第2步：初始化空仓库 $ vim ~/hexo_bare/hooks/post-receive 编辑: echo &quot;start 钩子&quot; git --work-tree=/usr/local/nginx/html/myblog --git-dir=/usr/local/hexo_bare checkout -f echo &quot;end 钩子&quot; 这里注意钩子post-ceive后面不带.sample，同时注意赋予权限： chmod +x post-receive 第3步：将空仓库关联到主仓库 $ git clone https://github.com/$username/hexo_static.git ~/hexo_static $ cd ~/hexo_static $ git remote add live ~/hexo_bare 这里给空库起名live ,可以在本地库hexo_static调用命令： git remote -v 查看到远程库名注意：查看下.git/config默认的库名是否是 [branch &quot;master&quot;] remote = origin merge = refs/heads/master 第4步：创建自动化脚本 $ vim ~/hexo_blog/hexo_git_deploy.sh 脚本内容： #!/bin/bash hexo clean hexo generate hexo deploy ( cd ~/hexo_static ; git pull origin; git push live master) 注意：这里一定要git pull origin,不然无法pull成功！ 第5步：nginx指定静态目录 在nginx的配置文件中配置即可 第6步：执行自动化 $ hexo new test $ sh hexo_git_deplay.sh 脚本自动化发布成功！可以看到钩子成功执行！查看nginx的静态目录。发现test文件已经存在，甚至不用重启nginx！至此完成自动化！","tags":[{"name":"hexo","slug":"hexo","permalink":"http://139.129.18.59/tags/hexo/"}]},{"title":"hexo代码高亮和自定义","date":"2016-11-14T03:10:06.000Z","path":"2016/11/14/hexo代码高亮和自定义/","text":"设置代码高亮设置好主题后，发布文章后，有的主题并没有设置代码高亮。要在hexo设置代码高亮，修改config： highlight: enable: true line_number: true auto_detect: true tab_replace: 然后themes的config也要添加相应的高亮配置。这段代码的作用，查看source/css/style.styl里面: @import &#39;nib&#39; global-reset() @import &#39;_base/variable&#39; @import &#39;_base/font&#39; @import &#39;_base/public&#39; @import &#39;_partial/header&#39; @import &#39;_partial/index&#39; @import &#39;_partial/article&#39; @import &#39;_partial/helper&#39; @import &#39;_partial/aside&#39; @import &#39;_partial/footer&#39; if highlight @import &#39;_base/code&#39; if duoshuo @import &#39;_partial/duoshuo&#39; if fancybox @import &#39;_partial/gallery&#39; 可以看到，如果设置highlight，那么就引入_base/code下面的css样式。 自定义代码高亮Wordpress有个Google Prettify插件，在这里也可以进行高亮显示。首先将config配置的highlight关闭： highlight: enable: false line_number: false auto_detect: false tab_replace: 然后我们需要下载prettify，并引入css和js文件 &lt;!-- 代码高亮--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/prettify.css&quot; type=&quot;text/css&quot;&gt; &lt;script src=&quot;/js/prettify.js&quot;type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 这段代码需要在页面的head引入：在layout的head.ejs文件中，我们可以查看有js,css文件引入，后面添加即可。 最后我们需要在网页加载完成之后调用即可： $(window).load(function(){ $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;); prettyPrint(); }) 注意：这段代码使用$(window).load，这是在页面加载完成后调用，跟(document).ready(function() 有所区别。前者只能调用一次，后者能调用多次。在这里，我们添加到文件after_footer.ejs中 $(document).ready(function(){ console.log(&quot;执行调用prettify start&quot;); $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;); prettyPrint(); console.log(&quot;执行调用prettify end&quot;); 另外关于代码高亮的主题，可以在这个网站选择一套你喜欢的主题替换上面的prettify.css即可。最后添加代码如下： #head.ejs &lt;!-- 代码高亮--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/tranquil-heart.min.css&quot; type=&quot;text/css&quot;&gt; &lt;script src=&quot;/js/prettify.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;","tags":[{"name":"hexo","slug":"hexo","permalink":"http://139.129.18.59/tags/hexo/"}]},{"title":"markdown的使用方法","date":"2016-10-14T03:10:06.000Z","path":"2016/10/14/markdown使用/","text":"马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供桌面客户端以及离线Chrome App，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块@requires_authorization def somefunc(param1=&#39;&#39;, param2=0): &#39;&#39;&#39;A docstring&#39;&#39;&#39; if param1 &gt; param2: # interesting print &#39;Greater&#39; return (param2 - param1 + 1) or None class SomeClass: pass &gt;&gt;&gt; message = &#39;&#39;&#39;interpreter ... prompt&#39;&#39;&#39; LaTeX 公式可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图st=&gt;start: Start e=&gt;end op=&gt;operation: My Operation cond=&gt;condition: Yes or No? st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op 以及时序图: Alice-&gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： [x] 已完成事项 [ ] 待办事项1 [ ] 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Ctrl + /同步文档 Ctrl + S创建文档 Ctrl + Alt + N最大化编辑器 Ctrl + Enter预览文档 Ctrl + Alt + Enter文档管理 Ctrl + O系统菜单 Ctrl + M 加粗 Ctrl + B插入图片 Ctrl + G插入链接 Ctrl + L提升标题 Ctrl + H 关于收费马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#x68;&#x75;&#x73;&#116;&#103;&#x6f;&#99;&#x6b;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。","tags":[{"name":"markdown","slug":"markdown","permalink":"http://139.129.18.59/tags/markdown/"}]},{"title":"nodejs开发笔记","date":"2016-09-16T14:10:06.000Z","path":"2016/09/16/备用/nodejs_01/","text":"安装我的系统是centos，以centos为例： 一、 yum方式安装要通过 yum 来安装 nodejs 和 npm 需要先给 yum 添加 epel 源：添加 epel 源:64位： rpm -ivh http://download.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm 32位： rpm -ivh http://download.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm 导入 key: rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6 添加 remi 源: rpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-6.rpm rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-remi 安装完成之后执行： ##注意：这步也许不需要 curl --silent --location https://rpm.nodesource.com/setup_5.x | bash - yum -y install nodejs 安装结束。 注意：如果安装过程提示gcc相关报错,需要先执行 yum install -y gcc-c++ make 再执行： yum -y install nodejs 二、 源码安装1.安装下载源码##这里源码地址自己替换最新的 cd /usr/local/src/ wget http://nodejs.org/dist/v0.10.24/node-v0.10.24.tar.gz 2.解压源码tar zxvf node-v0.10.24.tar.gz 3.编译安装cd node-v0.10.24 ./configure --prefix=/usr/local/node/0.10.24 make make install ./configure –prefix指定安装路径不指定prefix，则可执行文件默认放在/usr /local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc。其它的资源文件放在/usr /local/share。你要卸载这个程序，要么在原来的make目录下用一次make uninstall（前提是make文件指定过uninstall）,要么去上述目录里面把相关的文件一个个手工删掉。指定prefix，直接删掉一个文件夹就够了。 4.配置NODE_HOME进入profile编辑环境变量 vim /etc/profile 设置nodejs环境变量，在 export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL 一行的上面添加如下内容: #set for nodejs export NODE_HOME=/usr/local/node/0.10.24 export PATH=$NODE_HOME/bin:$PATH :wq保存并退出，编译/etc/profile 使配置生效 source /etc/profile 验证是否安装配置成功 node -v 输出 v0.10.24 表示配置成功。npm模块安装路径：/usr/local/node/0.10.24/lib/node_modules/","tags":[{"name":"后端","slug":"后端","permalink":"http://139.129.18.59/tags/后端/"},{"name":"nodejs","slug":"nodejs","permalink":"http://139.129.18.59/tags/nodejs/"}]}]