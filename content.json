[{"title":"PhotoSwipe中文API","date":"2016-11-23T04:10:06.000Z","path":"2016/11/23/相册js/","text":"PhotoSwipe 是专为移动触摸设备设计的相册/画廊.兼容所有iPhone、iPad、黑莓6+,以及桌面浏览器.底层实现基于HTML/CSS/JavaScript,是一款免费开源的相册产品 入门开始之前你应该知道的第一件事: PhotoSwipe不是一个简单的jQuery插件，至少需要基本的JavaScript知识来安装。 PhotoSwipe需要预先定义的图片尺寸（更多相关信息）。 如果您在非响应网站上使用PhotoSwipe，则控件将在移动设备上进行缩放（整个页面缩放）。因此，您需要实现自定义控件（例如右上角的单个大关闭按钮）。 文档中的所有代码都是纯Vanilla JS，并支持IE 8及更高版本。如果您的网站或应用程序使用一些JavaScript框架（如jQuery或MooTools）或您不需要支持旧的浏览器 - 随意简化代码。 避免为移动设备投放大图片（大于2000x1500像素），因为它们会大大降低动画效果，并可能导致崩溃（尤其是在iOS Safari上）。可能的解决方案：提供响应图像，或在单独的页面上打开图像，或使用支持图像平铺的库（如传单）（更多在常见问题）。初始化步骤1：包括JS和CSS文件你可以找到他们DIST /文件夹的GitHub存储库。Sass和未编译的JS文件位于文件夹src/中。如果您计划修改现有样式，我建议使用Sass，因为代码是结构化的和注释的。 &lt;!-- Core CSS file --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/photoswipe.css&quot;&gt; &lt;!-- Skin CSS file (styling of UI - buttons, caption, etc.) In the folder of skin CSS file there are also: - .png and .svg icons sprite, - preloader.gif (for browsers that do not support CSS animations) --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/default-skin/default-skin.css&quot;&gt; &lt;!-- Core JS file --&gt; &lt;script src=&quot;path/to/photoswipe.min.js&quot;&gt;&lt;/script&gt; &lt;!-- UI JS file --&gt; &lt;script src=&quot;path/to/photoswipe-ui-default.min.js&quot;&gt;&lt;/script&gt; 不管你如何和在哪里将包括JS和CSS文件。代码只有在您调用时才会执行new PhotoSwipe()。所以，如果你不需要PhotoSwipe最初打开，随意推迟文件加载。PhotoSwipe还支持AMD加载器（如RequireJS）和CommonJS，使用它们像这样： require([ &#39;path/to/photoswipe.js&#39;, &#39;path/to/photoswipe-ui-default.js&#39; ], function( PhotoSwipe, PhotoSwipeUI_Default ) { // var gallery = new PhotoSwipe( someElement, PhotoSwipeUI_Default ... // gallery.init() // ... }); 此外，您可以通过Bower（bower install photoswipe）或NPM（npm install photoswipe）安装它。 步骤2：向DOM中添加PhotoSwipe（.pswp）元素您可以通过JS动态添加HTML代码（直接在初始化之前），或者在页面中初始化（像在演示页面上完成）。这个代码可以追加到任何地方，但最好是在关闭之前。您可以在多个库中重复使用它（只要使用相同的UI类）。 &lt;!-- Root element of PhotoSwipe. Must have class pswp. --&gt; &lt;div class=&quot;pswp&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-hidden=&quot;true&quot;&gt; &lt;!-- Background of PhotoSwipe. It&#39;s a separate element as animating opacity is faster than rgba(). --&gt; &lt;div class=&quot;pswp__bg&quot;&gt;&lt;/div&gt; &lt;!-- Slides wrapper with overflow:hidden. --&gt; &lt;div class=&quot;pswp__scroll-wrap&quot;&gt; &lt;!-- Container that holds slides. PhotoSwipe keeps only 3 of them in the DOM to save memory. Don&#39;t modify these 3 pswp__item elements, data is added later on. --&gt; &lt;div class=&quot;pswp__container&quot;&gt; &lt;div class=&quot;pswp__item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pswp__item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pswp__item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. --&gt; &lt;div class=&quot;pswp__ui pswp__ui--hidden&quot;&gt; &lt;div class=&quot;pswp__top-bar&quot;&gt; &lt;!-- Controls are self-explanatory. Order can be changed. --&gt; &lt;div class=&quot;pswp__counter&quot;&gt;&lt;/div&gt; &lt;button class=&quot;pswp__button pswp__button--close&quot; title=&quot;Close (Esc)&quot;&gt;&lt;/button&gt; &lt;button class=&quot;pswp__button pswp__button--share&quot; title=&quot;Share&quot;&gt;&lt;/button&gt; &lt;button class=&quot;pswp__button pswp__button--fs&quot; title=&quot;Toggle fullscreen&quot;&gt;&lt;/button&gt; &lt;button class=&quot;pswp__button pswp__button--zoom&quot; title=&quot;Zoom in/out&quot;&gt;&lt;/button&gt; &lt;!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR --&gt; &lt;!-- element will get class pswp__preloader--active when preloader is running --&gt; &lt;div class=&quot;pswp__preloader&quot;&gt; &lt;div class=&quot;pswp__preloader__icn&quot;&gt; &lt;div class=&quot;pswp__preloader__cut&quot;&gt; &lt;div class=&quot;pswp__preloader__donut&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;pswp__share-modal pswp__share-modal--hidden pswp__single-tap&quot;&gt; &lt;div class=&quot;pswp__share-tooltip&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;button class=&quot;pswp__button pswp__button--arrow--left&quot; title=&quot;Previous (arrow left)&quot;&gt; &lt;/button&gt; &lt;button class=&quot;pswp__button pswp__button--arrow--right&quot; title=&quot;Next (arrow right)&quot;&gt; &lt;/button&gt; &lt;div class=&quot;pswp__caption&quot;&gt; &lt;div class=&quot;pswp__caption__center&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; pswp__bg，pswp__scroll-wrap，pswp__container和pswp__item元件的顺序不应被改变。你可能会问，为什么PhotoSwipe不通过JS自动添加这个代码，原因很简单 - 只是为了保存文件大小，万一你需要一些修改布局。 步骤3：初始化执行PhotoSwipe构造函数。它接受4个参数：1、.pswp元素（必须添加到DOM）。2、PhotoSwipe UI类。如果你包含默认photoswipe-ui-default.js，类将会PhotoSwipeUI_Default。可以false。3、具有对象的数组（幻灯片）。4、选项。 var pswpElement = document.querySelectorAll(&#39;.pswp&#39;)[0]; // build items array var items = [ { src: &#39;https://placekitten.com/600/400&#39;, w: 600, h: 400 }, { src: &#39;https://placekitten.com/1200/900&#39;, w: 1200, h: 900 } ]; // define options (if needed) var options = { // optionName: &#39;option value&#39; // for example: index: 0 // start at first slide }; // Initializes and opens PhotoSwipe var gallery = new PhotoSwipe( pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); 最后你应该得到这样的东西：HTML代码: &lt;button id=&quot;btn&quot;&gt;Open PhotoSwipe&lt;/button&gt; &lt;!-- Root element of PhotoSwipe. Must have class pswp. --&gt; &lt;div class=&quot;pswp&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-hidden=&quot;true&quot;&gt; &lt;!-- Background of PhotoSwipe. It&#39;s a separate element, as animating opacity is faster than rgba(). --&gt; &lt;div class=&quot;pswp__bg&quot;&gt;&lt;/div&gt; &lt;!-- Slides wrapper with overflow:hidden. --&gt; &lt;div class=&quot;pswp__scroll-wrap&quot;&gt; &lt;!-- Container that holds slides. PhotoSwipe keeps only 3 slides in DOM to save memory. --&gt; &lt;div class=&quot;pswp__container&quot;&gt; &lt;!-- don&#39;t modify these 3 pswp__item elements, data is added later on --&gt; &lt;div class=&quot;pswp__item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pswp__item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pswp__item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. --&gt; &lt;div class=&quot;pswp__ui pswp__ui--hidden&quot;&gt; &lt;div class=&quot;pswp__top-bar&quot;&gt; &lt;!-- Controls are self-explanatory. Order can be changed. --&gt; &lt;div class=&quot;pswp__counter&quot;&gt;&lt;/div&gt; &lt;button class=&quot;pswp__button pswp__button--close&quot; title=&quot;Close (Esc)&quot;&gt;&lt;/button&gt; &lt;button class=&quot;pswp__button pswp__button--share&quot; title=&quot;Share&quot;&gt;&lt;/button&gt; &lt;button class=&quot;pswp__button pswp__button--fs&quot; title=&quot;Toggle fullscreen&quot;&gt;&lt;/button&gt; &lt;button class=&quot;pswp__button pswp__button--zoom&quot; title=&quot;Zoom in/out&quot;&gt;&lt;/button&gt; &lt;!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR --&gt; &lt;!-- element will get class pswp__preloader--active when preloader is running --&gt; &lt;div class=&quot;pswp__preloader&quot;&gt; &lt;div class=&quot;pswp__preloader__icn&quot;&gt; &lt;div class=&quot;pswp__preloader__cut&quot;&gt; &lt;div class=&quot;pswp__preloader__donut&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;pswp__share-modal pswp__share-modal--hidden pswp__single-tap&quot;&gt; &lt;div class=&quot;pswp__share-tooltip&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;button class=&quot;pswp__button pswp__button--arrow--left&quot; title=&quot;Previous (arrow left)&quot;&gt; &lt;/button&gt; &lt;button class=&quot;pswp__button pswp__button--arrow--right&quot; title=&quot;Next (arrow right)&quot;&gt; &lt;/button&gt; &lt;div class=&quot;pswp__caption&quot;&gt; &lt;div class=&quot;pswp__caption__center&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; JS代码： var openPhotoSwipe = function() { var pswpElement = document.querySelectorAll(&#39;.pswp&#39;)[0]; // build items array var items = [ { src: &#39;https://farm2.staticflickr.com/1043/5186867718_06b2e9e551_b.jpg&#39;, w: 964, h: 1024 }, { src: &#39;https://farm7.staticflickr.com/6175/6176698785_7dee72237e_b.jpg&#39;, w: 1024, h: 683 } ]; // define options (if needed) var options = { // history &amp; focus options are disabled on CodePen history: false, focus: false, showAnimationDuration: 0, hideAnimationDuration: 0 }; var gallery = new PhotoSwipe( pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); }; openPhotoSwipe(); document.getElementById(&#39;btn&#39;).onclick = openPhotoSwipe; 创建幻灯片对象数组数组中的每个对象都应包含有关幻灯片的数据，它可以是您想要在PhotoSwipe中显示的任何内容 - 图片路径，字幕字符串，共享数量，评论等。默认情况下，PhotoSwipe仅使用5个属性：（src路径到图像），w（图像宽度），h（图像高度），msrc（小图像占位符的路径，大图像将被加载在顶部），html（自定义HTML，更多关于它）。在导航期间，PhotoSwipe会向此对象添加自己的属性（如minZoom或loaded） var slides = [ // slide 1 { src: &#39;path/to/image1.jpg&#39;, // path to image w: 1024, // image width h: 768, // image height msrc: &#39;path/to/small-image.jpg&#39;, // small image placeholder, // main (large) image loads on top of it, // if you skip this parameter - grey rectangle will be displayed, // try to define this property only when small image was loaded before title: &#39;Image Caption&#39; // used by Default PhotoSwipe UI // if you skip it, there won&#39;t be any caption // You may add more properties here and use them. // For example, demo gallery uses &quot;author&quot; property, which is used in the caption. // author: &#39;John Doe&#39; }, // slide 2 { src: &#39;path/to/image2.jpg&#39;, w: 600, h: 600 // etc. } // etc. ]; 您可以在PhotoSwipe读取它们之前直接动态定义幻灯片对象属性，使用gettingData事件（更多信息在文档的API部分）。例如，该技术可以用于为不同的屏幕尺寸提供不同的图像。 如何从链接列表构建幻灯片数组假设您有一个看起来像这样的链接/缩略图列表（关于图库标记的更多信息）： &lt;div class=&quot;my-gallery&quot; itemscope itemtype=&quot;http://schema.org/ImageGallery&quot;&gt; &lt;figure itemprop=&quot;associatedMedia&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt; &lt;a href=&quot;large-image.jpg&quot; itemprop=&quot;contentUrl&quot; data-size=&quot;600x400&quot;&gt; &lt;img src=&quot;small-image.jpg&quot; itemprop=&quot;thumbnail&quot; alt=&quot;Image description&quot; /&gt; &lt;/a&gt; &lt;figcaption itemprop=&quot;caption description&quot;&gt;Image caption&lt;/figcaption&gt; &lt;/figure&gt; &lt;figure itemprop=&quot;associatedMedia&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt; &lt;a href=&quot;large-image.jpg&quot; itemprop=&quot;contentUrl&quot; data-size=&quot;600x400&quot;&gt; &lt;img src=&quot;small-image.jpg&quot; itemprop=&quot;thumbnail&quot; alt=&quot;Image description&quot; /&gt; &lt;/a&gt; &lt;figcaption itemprop=&quot;caption description&quot;&gt;Image caption&lt;/figcaption&gt; &lt;/figure&gt; &lt;/div&gt; …并且您想要点击缩略图以大图片打开PhotoSwipe（就像在演示页上完成的一样）。所有你需要做的是：1、将点击事件绑定到链接/缩略图。2、用户点击缩略图后，找到其索引。3、从DOM元素创建幻灯片对象数组 - 循环遍历所有链接并检索href属性（大图片网址），data-size属性（其大小），src缩略图和标题内容。PhotoSwipe真的不在乎你会怎么做。如果你使用jQuery或MooTools等框架，或者如果你不需要支持IE8，代码可以大大简化。这里是纯IE的支持的vanilla JS实现： var initPhotoSwipeFromDOM = function(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function(el) { var thumbElements = el.childNodes, numNodes = thumbElements.length, items = [], figureEl, linkEl, size, item; for(var i = 0; i &lt; numNodes; i++) { figureEl = thumbElements[i]; // &lt;figure&gt; element // include only element nodes if(figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // &lt;a&gt; element size = linkEl.getAttribute(&#39;data-size&#39;).split(&#39;x&#39;); // create slide object item = { src: linkEl.getAttribute(&#39;href&#39;), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if(figureEl.children.length &gt; 1) { // &lt;figcaption&gt; content item.title = figureEl.children[1].innerHTML; } if(linkEl.children.length &gt; 0) { // &lt;img&gt; thumbnail element, retrieving thumbnail url item.msrc = linkEl.children[0].getAttribute(&#39;src&#39;); } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el &amp;&amp; ( fn(el) ? el : closest(el.parentNode, fn) ); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return (el.tagName &amp;&amp; el.tagName.toUpperCase() === &#39;FIGURE&#39;); }); if(!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, childNodes = clickedListItem.parentNode.childNodes, numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i &lt; numChildNodes; i++) { if(childNodes[i].nodeType !== 1) { continue; } if(childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if(index &gt;= 0) { // open PhotoSwipe if valid index found openPhotoSwipe( index, clickedGallery ); } return false; }; // parse picture index and gallery index from URL (#&amp;pid=1&amp;gid=2) var photoswipeParseHash = function() { var hash = window.location.hash.substring(1), params = {}; if(hash.length &lt; 5) { return params; } var vars = hash.split(&#39;&amp;&#39;); for (var i = 0; i &lt; vars.length; i++) { if(!vars[i]) { continue; } var pair = vars[i].split(&#39;=&#39;); if(pair.length &lt; 2) { continue; } params[pair[0]] = pair[1]; } if(params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll(&#39;.pswp&#39;)[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute(&#39;data-pswp-uid&#39;), getThumbBoundsFn: function(index) { // See Options -&gt; getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName(&#39;img&#39;)[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return {x:rect.left, y:rect.top + pageYScroll, w:rect.width}; } }; // PhotoSwipe opened from URL if(fromURL) { if(options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for(var j = 0; j &lt; items.length; j++) { if(items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if( isNaN(options.index) ) { return; } if(disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe( pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll( gallerySelector ); for(var i = 0, l = galleryElements.length; i &lt; l; i++) { galleryElements[i].setAttribute(&#39;data-pswp-uid&#39;, i+1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&amp;pid=3&amp;gid=1 var hashData = photoswipeParseHash(); if(hashData.pid &amp;&amp; hashData.gid) { openPhotoSwipe( hashData.pid , galleryElements[ hashData.gid - 1 ], true, true ); } }; // execute above function initPhotoSwipeFromDOM(&#39;.my-gallery&#39;); 提示：您可以从CodePen下载示例以在本地播放（Edit on CodePen- &gt; Share- &gt; Export .zip）。如果您使用的标记与此示例不同，则需要编辑功能parseThumbnailElements。如果你没有纯粹的JavaScript经验，并且不知道如何解析DOM，请参考QuirksMode和MDN上的文档。请注意，IE8不支持HTML5和元素，因此您需要在节中包含html5shiv（cdnjs托管版本用于示例）：","tags":[{"name":"相册","slug":"相册","permalink":"http://139.129.18.59/tags/相册/"},{"name":"PhotoSwipe","slug":"PhotoSwipe","permalink":"http://139.129.18.59/tags/PhotoSwipe/"}]},{"title":"tomcat的部署","date":"2016-11-15T05:10:06.000Z","path":"2016/11/15/tomcat的部署/","text":"安装tomcat需要预先安装JDK, JDK安装方法参考如下文档：http://help.aliyun.com/knowledge_detail/6507861.html?spm=5176.7114037.1996646101.1.FD0keL&amp;pos=1 本文将tomcat安装到了/usr/local/jdk1.8.0_60目录下，如果安装到了其他目录，请替换掉本文的JDK目录。 1. 下载tomcat：#wget http://apache.fayea.com/tomcat/tomcat-7/v7.0.64/bin/apache-tomcat-7.0.64.tar.gz 如果下载404，重新找路径apache.fayea.com/tomcat/tomcat-7/v7.0.69/bin/apache-tomcat-7.0.69.tar.gz 2. 将tomcat放置到 /usr/local/ 目录下#mv apache-tomcat-7.0.64.tar.gz /usr/local/ 3. 解压缩：tar -xvzf /usr/local/apache-tomcat-7.0.64.tar.gz 4. 设置tomcat开机自启动编辑/usr/local/apache-tomcat-7.0.64.tar.gz/bin/startup.sh # vi /usr/local/apache-tomcat-7.0.64/bin/startup.sh 加入如下行： #chkconfig: 2345 80 90 #description:tomcat auto start #processname: tomcat 编辑/usr/local/apache-tomcat-7.0.64/bin/catalina.sh # vi /usr/local/apache-tomcat-7.0.64/bin/catalina.sh 搜索export关键字，加入如下行： export CATALINA_BASE=/usr/local/apache-tomcat-7.0.64 export CATALINA_HOME=/usr/local/apache-tomcat-7.0.64 export CATALINA_TMPDIR=/usr/local/apache-tomcat-7.0.64 将tomcat加入开机自启动 # vi /etc/rc.d/rc.local 加入如下内容： export JAVA_HOME=/usr/local/jdk1.8.0_60 /usr/local/apache-tomcat-7.0.64/bin/startup.sh start 执行 # /usr/local/apache-tomcat-7.0.64/bin/startup.sh 启动tomcat 打开浏览器测试：tomcat默认监听8080端口，如果要修改成为80端口，按如下步骤修改： # vi /usr/local/apache-tomcat-7.0.64/conf/server.xml 找到 &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; &lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 修改为： &lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; &lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 重启tomcat生效","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://139.129.18.59/tags/tomcat/"}]},{"title":"NFS安装配置","date":"2016-11-15T04:10:06.000Z","path":"2016/11/15/NFS安装配置/","text":"一、NFS服务简介 NFS 是Network File System的缩写，即网络文件系统。一种使用于分散式文件系统的协定，由Sun公司开发，于1984年向外公布。功能是通过网络让不同的机器、不同的操作系统能够彼此分享个别的数据，让应用程序在客户端通过网络访问位于服务器磁盘中的数据，是在类Unix系统间实现磁盘文件共享的一种方法。 NFS 的基本原则是“容许不同的客户端及服务端通过一组RPC分享相同的文件系统”，它是独立于操作系统，容许不同硬件及操作系统的系统共同进行文件的分享。 NFS在文件传送或信息传送过程中依赖于RPC协议。RPC，远程过程调用 (Remote Procedure Call) 是能使客户端执行其他系统中程序的一种机制。NFS本身是没有提供信息传输的协议和功能的，但NFS却能让我们通过网络进行资料的分享，这是因为NFS使用了一些其它的传输协议。而这些传输协议用到这个RPC功能的。可以说NFS本身就是使用RPC的一个程序。或者说NFS也是一个RPC SERVER。所以只要用到NFS的地方都要启动RPC服务，不论是NFS SERVER或者NFS CLIENT。这样SERVER和CLIENT才能通过RPC来实现PROGRAM PORT的对应。可以这么理解RPC和NFS的关系：NFS是一个文件系统，而RPC是负责负责信息的传输。 二、系统环境系统平台：CentOS release 5.6 (Final) NFS Server IP：192.168.1.108 防火墙已关闭/iptables: Firewall is not running. SELINUX=disabled 三、检查安装NFS服务（旧版linux安装）NFS的安装是非常简单的，只需要两个软件包即可，而且在通常情况下，是作为系统的默认包安装的。 nfs-utils- * ：包括基本的NFS命令与监控程序 portmap- * ：支持安全NFS RPC服务的连接1、查看系统是否已安装NFS[cttq@ainewdev ~]$ rpm -qa|grep nfs nfs4-acl-tools-0.3.3-8.el6.x86_64 nfs-utils-1.2.3-70.el6_8.2.x86_64 nfs-utils-lib-1.1.5-11.el6.x86_64 [cttq@ainewdev ~]$ rpm -qa|grep portmap 系统默认已安装了nfs-utils portmap 两个软件包。 2、如果当前系统中没有安装NFS所需的软件包，需要手工进行安装。nfs-utils 和portmap 两个包的安装文件在系统光盘中都会有。# mount /dev/cdrom /mnt/cdrom/ # cd /mnt/cdrom/CentOS/ # rpm -ivh portmap-4.0-65.2.2.1.i386.rpm # rpm -ivh nfs-utils-1.0.9-50.el5.i386.rpm # rpm -q nfs-utils portmap 检查的时候发现portmap不存在，命令 more /etc/issue 查看当前系统版本：CentOS release 6.8 上面的portmap服务在centos 6.4中已经被rpcbind取代，所以采用下面的检查安装方法：。 1、检查系统是否开启nfs服务：service nfs status 结果显示nfs: unrecognized service，说明系统没有安装nfs服务,so 安装之；注意，yum install nfs是无法安装的，应该用yum install nfs-utils. 2、检查是否开启rpcbind服务：service rpcbind status发现已经在nfs-utils的时候一起安装了。总结：yum install nfs-utils 四、NFS系统守护进程 nfsd：它是基本的NFS守护进程，主要功能是管理客户端是否能够登录服务器； mountd：它是RPC安装守护进程，主要功能是管理NFS的文件系统。当客户端顺利通过nfsd登录NFS服务器后，在使用NFS服务所提供的文件前，还必须通过文件使用权限的验证。它会读取NFS的配置文件/etc/exports来对比客户端权限。 portmap：主要功能是进行端口映射工作。当客户端尝试连接并使用RPC服务器提供的服务（如NFS服务）时，portmap会将所管理的与服务对应的端口提供给客户端，从而使客户可以通过该端口向服务器请求服务。五、NFS服务器的配置 NFS服务器的配置相对比较简单，只需要在相应的配置文件中进行设置，然后启动NFS服务器即可。 NFS的常用目录: /etc/exports NFS服务的主要配置文件/usr/sbin/exportfs NFS服务的管理命令/usr/sbin/showmount 客户端的查看命令/var/lib/nfs/etab 记录NFS分享出来的目录的完整权限设定值/var/lib/nfs/xtab 记录曾经登录过的客户端信息NFS服务的配置文件为 /etc/exports，这个文件是NFS的主要配置文件，不过系统并没有默认值，所以这个文件不一定会存在，可能要使用vim手动建立，然后在文件里面写入配置内容。 /etc/exports文件内容格式： &lt;输出目录&gt; [客户端1 选项（访问权限,用户映射,其他）] [客户端2 选项（访问权限,用户映射,其他）] a. 输出目录：输出目录是指NFS系统中需要共享给客户机使用的目录； b. 客户端：客户端是指网络中可以访问这个NFS输出目录的计算机 客户端常用的指定方式 指定ip地址的主机：192.168.0.200 指定子网中的所有主机：192.168.0.0/24 192.168.0.0/255.255.255.0 指定域名的主机：david.bsmart.cn 指定域中的所有主机：*.bsmart.cn 所有主机：* c. 选项：选项用来设置输出目录的访问权限、用户映射等。 NFS主要有3类选项： 访问权限选项 设置输出目录只读：ro 设置输出目录读写：rw用户映射选项 all_squash：将远程访问的所有普通用户及所属组都映射为匿名用户或用户组（nfsnobody）； no_all_squash：与all_squash取反（默认设置）； root_squash：将root用户及所属组都映射为匿名用户或用户组（默认设置）； no_root_squash：与rootsquash取反； anonuid=xxx：将远程访问的所有用户都映射为匿名用户，并指定该用户为本地用户（UID=xxx）； anongid=xxx：将远程访问的所有用户组都映射为匿名用户组账户，并指定该匿名用户组账户为本地用户组账户（GID=xxx）；其它选项 secure：限制客户端只能从小于1024的tcp/ip端口连接nfs服务器（默认设置）； insecure：允许客户端从大于1024的tcp/ip端口连接服务器； sync：将数据同步写入内存缓冲区与磁盘中，效率低，但可以保证数据的一致性； async：将数据先保存在内存缓冲区中，必要时才写入磁盘； wdelay：检查是否有相关的写操作，如果有则将这些写操作一起执行，这样可以提高效率（默认设置）； no_wdelay：若有写操作则立即执行，应与sync配合使用； subtree：若输出目录是一个子目录，则nfs服务器将检查其父目录的权限(默认设置)； no_subtree：即使输出目录是一个子目录，nfs服务器也不检查其父目录的权限，这样可以提高效率； 六、NFS服务器的启动与停止在对exports文件进行了正确的配置后，就可以启动NFS服务器了。 1、启动NFS服务器为了使NFS服务器能正常工作，需要启动portmap和nfs两个服务，并且portmap一定要先于nfs启动。 # service rpcbind start # service nfs start 2、查询NFS服务器状态# service rpcbind status # service nfs status 3、停止NFS服务器要停止NFS运行时，需要先停止nfs服务再停止portmap服务，对于系统中有其他服务(如NIS)需要使用时，不需要停止portmap服务 # service nfs stop # service rpcbind stop 4、设置NFS服务器的自动启动状态对于实际的应用系统，每次启动LINUX系统后都手工启动nfs服务器是不现实的，需要设置系统在指定的运行级别自动启动portmap(rpcbind)和nfs服务。 # chkconfig --list rpcbind # chkconfig --list nfs 设置portmap和nfs服务在系统运行级别3和5自动启动。 # chkconfig --level 35 portmap on # chkconfig --level 35 nfs on 七、实例1、将NFS Server 的/home/david/ 共享给192.168.1.0/24网段，权限读写。服务器端文件详细如下： # vi /etc/exports /home/david 192.168.1.0/24(rw) 2、重启portmap 和nfs 服务# service portmap restart # service nfs restart # exportfs 3、服务器端使用showmount命令查询NFS的共享状态# showmount -e //默认查看自己共享的服务，前提是要DNS能解析自己，不然容易报错 # showmount -a //显示已经与客户端连接上的目录信息 4、客户端使用showmount命令查询NFS的共享状态# showmount -e NFS服务器IP 5、客户端挂载NFS服务器中的共享目录命令格式 # mount NFS服务器IP:共享目录 本地挂载点目录 # mount 192.168.1.108:/home/david/ /tmp/david/ # mount |grep nfs 挂载成功。 查看文件是否和服务器端一致。 6、NFS的共享权限和访问控制现在我们在/tmp/david/ 里面建立一个文件，看看权限是什么 # touch 20130103 这里出现Permission denied，是因为NFS 服务器端共享的目录本身的写权限没有开放给其他用户，在服务器端打开该权限。 # chmod 777 -R /home/david/ 再次在客户端/tmp/david/ 里面建立一个文件 我用root 用户建立的文件，变成了nfsnobody 用户。 NFS有很多默认的参数，打开/var/lib/nfs/etab 查看分享出来的/home/david/ 完整权限设定值。 # cat /var/lib/nfs/etab 默认就有sync，wdelay，hide 等等，no_root_squash 是让root保持权限，root_squash 是把root映射成nobody，no_all_squash 不让所有用户保持在挂载目录中的权限。所以，root建立的文件所有者是nfsnobody。 下面我们使用普通用户挂载、写入文件测试。 # su - david $ cd /tmp/david/ $ touch 2013david 普通用户写入文件时就是自己的名字，这也就保证了服务器的安全性。关于权限的分析 1. 客户端连接时候，对普通用户的检查 a. 如果明确设定了普通用户被压缩的身份，那么此时客户端用户的身份转换为指定用户； b. 如果NFS server上面有同名用户，那么此时客户端登录账户的身份转换为NFS server上面的同名用户； c. 如果没有明确指定，也没有同名用户，那么此时 用户身份被压缩成nfsnobody； 2. 客户端连接的时候，对root的检查 a. 如果设置no_root_squash，那么此时root用户的身份被压缩为NFS server上面的root； b. 如果设置了all_squash、anonuid、anongid，此时root 身份被压缩为指定用户； c. 如果没有明确指定，此时root用户被压缩为nfsnobody； d. 如果同时指定no_root_squash与all_squash 用户将被压缩为 nfsnobody，如果设置了anonuid、anongid将被压缩到所指定的用户与组； 7、卸载已挂载的NFS共享目录# umount /tmp/david/ 八、启动自动挂载nfs文件系统格式： &lt;server&gt;:&lt;/remote/export&gt; &lt;/local/directory&gt; nfs &lt; options&gt; 0 0 # vi /etc/fstab 保存退出，重启系统。 查看/home/david 有没有自动挂载。 自动挂载成功。 九、相关命令1、exportfs 如果我们在启动了NFS之后又修改了/etc/exports，是不是还要重新启动nfs呢？这个时候我们就可以用exportfs 命令来使改动立刻生效，该命令格式如下： # exportfs [-aruv] -a 全部挂载或卸载 /etc/exports中的内容 -r 重新读取/etc/exports 中的信息 ，并同步更新/etc/exports、/var/lib/nfs/xtab -u 卸载单一目录（和-a一起使用为卸载所有/etc/exports文件中的目录） -v 在export的时候，将详细的信息输出到屏幕上。 具体例子： # exportfs -au 卸载所有共享目录 # exportfs -rv 重新共享所有目录并输出详细信息 2、nfsstat 查看NFS的运行状态，对于调整NFS的运行有很大帮助。 3、rpcinfo 查看rpc执行信息，可以用于检测rpc运行情况的工具，利用rpcinfo -p 可以查看出RPC开启的端口所提供的程序有哪些。 4、showmount -a 显示已经于客户端连接上的目录信息 -e IP或者hostname 显示此IP地址分享出来的目录 5、netstat 可以查看出nfs服务开启的端口，其中nfs 开启的是2049，portmap 开启的是111，其余则是rpc开启的。 最后注意两点，虽然通过权限设置可以让普通用户访问，但是挂载的时候默认情况下只有root可以去挂载，普通用户可以执行sudo。 NFS server 关机的时候一点要确保NFS服务关闭，没有客户端处于连接状态！通过showmount -a 可以查看，如果有的话用kill killall pkill 来结束，（-9 强制结束） CentOS 6.3下Samba服务器的安装与配置http://www.cnblogs.com/mchina/archive/2012/12/18/2816717.html","tags":[{"name":"nfs","slug":"nfs","permalink":"http://139.129.18.59/tags/nfs/"}]},{"title":"hexo同步到github","date":"2016-11-15T04:10:06.000Z","path":"2016/11/15/hexo同步到github/","text":"上传本地项目到github 建立Git仓库git init 将项目文件添加到仓库中git add . 注意：add后面有个 . 将我们添加的文件commit到git仓库， 添加注释git commit -m &quot;注释&quot; 将本地的仓库与github上的仓库进行关联 git remote add origin &quot;git仓库的地址&quot; 在这个工程中可能要求你输入账户密码，我们先保存ssh密钥在git上，使用git协议的地址就不会要求你输入了。 上传之前我们先从git上拉取一下 git pull origin master push本地项目到远程仓库git push -u origin master 至此项目就上传到github上了。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://139.129.18.59/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://139.129.18.59/tags/github/"}]},{"title":"hexo代码高亮和自定义","date":"2016-11-14T03:10:06.000Z","path":"2016/11/14/hexo代码高亮和自定义/","text":"设置代码高亮设置好主题后，发布文章后，有的主题并没有设置代码高亮。要在hexo设置代码高亮，修改config： highlight: enable: true line_number: true auto_detect: true tab_replace: 然后themes的config也要添加相应的高亮配置。这段代码的作用，查看source/css/style.styl里面: @import &#39;nib&#39; global-reset() @import &#39;_base/variable&#39; @import &#39;_base/font&#39; @import &#39;_base/public&#39; @import &#39;_partial/header&#39; @import &#39;_partial/index&#39; @import &#39;_partial/article&#39; @import &#39;_partial/helper&#39; @import &#39;_partial/aside&#39; @import &#39;_partial/footer&#39; if highlight @import &#39;_base/code&#39; if duoshuo @import &#39;_partial/duoshuo&#39; if fancybox @import &#39;_partial/gallery&#39; 可以看到，如果设置highlight，那么就引入_base/code下面的css样式。 自定义代码高亮Wordpress有个Google Prettify插件，在这里也可以进行高亮显示。首先将config配置的highlight关闭： highlight: enable: false line_number: false auto_detect: false tab_replace: 然后我们需要下载prettify，并引入css和js文件 &lt;!-- 代码高亮--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/prettify.css&quot; type=&quot;text/css&quot;&gt; &lt;script src=&quot;/js/prettify.js&quot;type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 这段代码需要在页面的head引入：在layout的head.ejs文件中，我们可以查看有js,css文件引入，后面添加即可。 最后我们需要在网页加载完成之后调用即可： $(window).load(function(){ $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;); prettyPrint(); }) 注意：这段代码使用$(window).load，这是在页面加载完成后调用，跟(document).ready(function() 有所区别。前者只能调用一次，后者能调用多次。在这里，我们添加到文件after_footer.ejs中 $(document).ready(function(){ console.log(&quot;执行调用prettify start&quot;); $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;); prettyPrint(); console.log(&quot;执行调用prettify end&quot;); 另外关于代码高亮的主题，可以在这个网站选择一套你喜欢的主题替换上面的prettify.css即可。最后添加代码如下： #head.ejs &lt;!-- 代码高亮--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/tranquil-heart.min.css&quot; type=&quot;text/css&quot;&gt; &lt;script src=&quot;/js/prettify.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;","tags":[{"name":"hexo","slug":"hexo","permalink":"http://139.129.18.59/tags/hexo/"}]},{"title":"hexo部署和自动化发布","date":"2016-11-14T03:10:06.000Z","path":"2016/11/14/hexo自动化/","text":"这里安装hexo过程省略，参考其他文章。这里主要说下如何利用git自动化发布： 安装git：sudo apt-get install git 创建GitHub Repository ，在git上创建一个reop库，取名hexo_static 安装插件 $ npm install hexo-deployer-git --save 修改配置文件 deploy: type: git repo: git@github.com:$username/hexo_static.git branch: master 注意替换username为自己的git名字，注意这里如果使用https协议的git，那么每次都会要求输入账户和密码，这里使用git协议，在ssh里保存密钥，这样不用每次都输入密码 执行命令 $ hexo generate $ hexo deploy generate: 生成静态文件，文件生成在pulic目录下deploy: 发布到git的库hexo_static 实现自动化 这里实现自动化思路：通过git –bare 生成一个裸库bare，裸库bare作为一个远程库remote，在裸库实现一个钩子post-receive，当本地库进行push的时候，自动运行钩子，从而更新静态文件目录A，使用nginx进行转发到静态文件目录A。 第1步：初始化空仓库 $ git init --bare ~/hexo_bare 第2步：初始化空仓库 $ vim ~/hexo_bare/hooks/post-receive 编辑: echo &quot;start 钩子&quot; git --work-tree=/usr/local/nginx/html/myblog --git-dir=/usr/local/hexo_bare checkout -f echo &quot;end 钩子&quot; 这里注意钩子post-ceive后面不带.sample，同时注意赋予权限： chmod +x post-receive 第3步：将空仓库关联到主仓库 $ git clone https://github.com/$username/hexo_static.git ~/hexo_static $ cd ~/hexo_static $ git remote add live ~/hexo_bare 这里给空库起名live ,可以在本地库hexo_static调用命令： git remote -v 查看到远程库名注意：查看下.git/config默认的库名是否是 [branch &quot;master&quot;] remote = origin merge = refs/heads/master 第4步：创建自动化脚本 $ vim ~/hexo_blog/hexo_git_deploy.sh 脚本内容： #!/bin/bash hexo clean hexo generate hexo deploy ( cd ~/hexo_static ; git pull origin; git push live master) 注意：这里一定要git pull origin,不然无法pull成功！ 第5步：nginx指定静态目录 在nginx的配置文件中配置即可 第6步：执行自动化 $ hexo new test $ sh hexo_git_deplay.sh 脚本自动化发布成功！可以看到钩子成功执行！查看nginx的静态目录。发现test文件已经存在，甚至不用重启nginx！至此完成自动化！","tags":[{"name":"hexo","slug":"hexo","permalink":"http://139.129.18.59/tags/hexo/"}]},{"title":"hexo发布文章注意","date":"2016-11-14T03:10:06.000Z","path":"2016/11/14/hexo配置注意的地方/","text":"注意点1：发布的时候,检查_config.yml内容，特别注意:后面需要有一个空格：tags: markdown不然会报错：can not read a block mapping entry; a multiline key may not be an implicit key","tags":[{"name":"hexo","slug":"hexo","permalink":"http://139.129.18.59/tags/hexo/"}]},{"title":"markdown的使用方法","date":"2016-10-14T03:10:06.000Z","path":"2016/10/14/markdown使用/","text":"马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供桌面客户端以及离线Chrome App，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块@requires_authorization def somefunc(param1=&#39;&#39;, param2=0): &#39;&#39;&#39;A docstring&#39;&#39;&#39; if param1 &gt; param2: # interesting print &#39;Greater&#39; return (param2 - param1 + 1) or None class SomeClass: pass &gt;&gt;&gt; message = &#39;&#39;&#39;interpreter ... prompt&#39;&#39;&#39; LaTeX 公式可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图st=&gt;start: Start e=&gt;end op=&gt;operation: My Operation cond=&gt;condition: Yes or No? st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op 以及时序图: Alice-&gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： [x] 已完成事项 [ ] 待办事项1 [ ] 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Ctrl + /同步文档 Ctrl + S创建文档 Ctrl + Alt + N最大化编辑器 Ctrl + Enter预览文档 Ctrl + Alt + Enter文档管理 Ctrl + O系统菜单 Ctrl + M 加粗 Ctrl + B插入图片 Ctrl + G插入链接 Ctrl + L提升标题 Ctrl + H 关于收费马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#104;&#x75;&#115;&#116;&#x67;&#111;&#99;&#x6b;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。","tags":[{"name":"markdown","slug":"markdown","permalink":"http://139.129.18.59/tags/markdown/"}]},{"title":"博客的Hello World","date":"2016-09-10T04:10:06.000Z","path":"2016/09/10/World/","text":"其实我个人没有网上写作的习惯，以前也玩过不少博客，但是样式都不咋样，写了几篇之后就没有心情了。某天突然看到hexo居然能写出这么好看的博客，就打算玩下去。准备陆续将以前的笔记整理发布出来。 ——by ken","tags":[{"name":"随笔","slug":"随笔","permalink":"http://139.129.18.59/tags/随笔/"}]}]